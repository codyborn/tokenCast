
@{
    ViewData["Title"] = "Account";
}

<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.0.0-beta.34/dist/web3.min.js"></script>
    <script charset="utf-8"
            src="https://cdn.ethers.io/scripts/ethers-v4.min.js"
            type="text/javascript">
    </script>

    <script type="text/javascript" src="https://unpkg.com/web3@1.2.11/dist/web3.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/web3modal@1.9.0/dist/index.js"></script>
    <script type="text/javascript" src="https://unpkg.com/evm-chains@0.2.0/dist/umd/index.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/@@walletconnect/web3-provider@1.2.1/dist/umd/index.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/fortmatic@2.0.6/dist/fortmatic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/authereum@latest/authereum.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bitski@0.10.8/dist/bitski.min.js"></script>

    <script src="~/js/vibrant.min.js"></script>
    <script src="~/js/whiteLabelers.js"></script>
    <link rel="stylesheet" href="~/css/Hamburger.css">
    <link rel="stylesheet" href="~/css/Sidebar.css">
    <link rel="stylesheet" href="~/css/Button.css">
    <link rel="stylesheet" href="~/css/MenuFont.css">
    
    <script type="text/javascript" src="js/random-words.js"></script>
    <script type="text/javascript" src="js/tezos-beacon.js"></script>
    <script type="text/javascript">
        (function (w) {
            w.URLSearchParams = w.URLSearchParams || function (searchString) {
                var self = this;
                self.searchString = searchString;
                self.get = function (name) {
                    var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(self.searchString);
                    if (results == null) {
                        return null;
                    }
                    else {
                        return decodeURI(results[1]).toLowerCase() || 0;
                    }
                };
            }
        })(window)

        function loadStylesheet(url) {
            if (document.createStyleSheet) {
                document.createStyleSheet(url);
            } else {
                var styles = "@@import url(" + url + ");";
                var newSS = document.createElement('link');
                newSS.rel = 'stylesheet';
                newSS.href = 'data:text/css,' + escape(styles);
                document.getElementsByTagName("head")[0].appendChild(newSS);
            }
        }

        function setFavicon(url) {
            var link = document.querySelector("link[rel~='icon']");
            if (!link) {
                link = document.createElement('link');
                link.rel = 'icon';
                document.getElementsByTagName('head')[0].appendChild(link);
            }
            link.href = url;
        }

        web3Account = "";
        signature = "";
        defaultDeviceId = "";
        vueMounted = false
        windowLoaded = false
        outstandingSignatureRequest = false;
        const Web3Modal = window.Web3Modal.default;
        const WalletConnectProvider = window.WalletConnectProvider.default;
        ETHEREUM = "ETHEREUM";
        TEZOS = "TEZOS";

        /**
         * Setup the Web3Modal
         */
        function web3ModalInit() {

            console.log("Initializing example");
            console.log("WalletConnectProvider is", WalletConnectProvider);
            console.log("Fortmatic is", Fortmatic);
            console.log("window.web3 is", window.web3, "window.ethereum is", window.ethereum);

            // Check that the web page is run in a secure context,
            // as otherwise MetaMask won't be available
            if (location.protocol !== 'https:') {
                // https://ethereum.stackexchange.com/a/62217/620
                return;
            }

            // Tell Web3modal what providers we have available.
            // Built-in web browser provider (only one can exist as a time)
            // like MetaMask, Brave or Opera is added automatically by Web3modal
            const providerOptions = {
                authereum: {
                    package: Authereum // required
                },
                walletconnect: {
                    package: WalletConnectProvider,
                    options: {
                        infuraId: "9d5e849c49914b7092581cc71e3c2580",
                    }
                },
                // Bug: https://github.com/Web3Modal/web3modal/issues/231
                //fortmatic: {
                //    package: Fortmatic,
                //    options: {
                //        key: "pk_test_BCDB8DBBFE1F5B55"
                //    }
                //},
                //bitski: {
                //    package: Bitski, // required
                //    options: {
                //        clientId: "76674289-906f-451a-9aa4-6353f3bc442a", // required
                //        callbackUrl: "https://tokencast.net/account" // required
                //    }
                //}
            };

            web3Modal = new Web3Modal({
                cacheProvider: true, // optional
                providerOptions, // required
                disableInjectedProvider: false, // optional. For MetaMask / Brave / Opera.
            });

            console.log("Web3Modal instance is", web3Modal);
        }

        async function initProvider() {
            try {
                provider = await web3Modal.connect();
            } catch (e) {
                console.log("Could not get a wallet connection", e);
                return;
            }

            // Subscribe to accounts change
            provider.on("accountsChanged", (accounts) => {
                LoginUser();
            });

            // Subscribe to chainId change
            provider.on("chainChanged", (chainId) => {
                LoginUser();
            });

            // Subscribe to networkId change
            provider.on("networkChanged", (networkId) => {
                LoginUser();
            });
        }
        
        async function getTezosAccount() {
            await initTezosAccount(true);          
        }

        async function onConnectEthereum() {
            app.network = ETHEREUM;
            await initProvider();
            await LoginUser();
        }        
        
        async function onConnectTezos() {
            app.network = TEZOS;
            await getTezosAccount();
            await LoginUser();
        }

        async function onLoad(mounted, loaded) {
            vueMounted = vueMounted || mounted;
            windowLoaded = windowLoaded || loaded;
            if (vueMounted && windowLoaded) {
                //Web3Modal adds the key "WEB3_CONNECT_CACHED_PROVIDER" in localStorage after a successful connection, value is the provider name
                web3ModalCachedProvider = window.localStorage.getItem("WEB3_CONNECT_CACHED_PROVIDER")
                if (web3ModalCachedProvider !== undefined && web3ModalCachedProvider !== "" && web3ModalCachedProvider !== null) {
                    web3ModalInit();
                    await initProvider();
                    await initEthereumAccount();
                    await GetAccountIfSignatureExists(ETHEREUM);
                } else {
                    await initTezosAccount(false)
                    await GetAccountIfSignatureExists(TEZOS);
                }
            }
        }

        function checkWhitelabel() {
            for (var whiteLabeler in whiteLabelers) {
                if (window.location.origin.indexOf(whiteLabelers[whiteLabeler].url) >= 0) {
                    app.whitelabeler = whiteLabeler;
                    break;
                }
            }
            if (!app.whitelabeled) {
                var urlParams = new URLSearchParams(window.location.search);
                whitelabeler = urlParams.get("whitelabel");
                app.whitelabeler = whitelabeler;
            }
            if (app.whitelabeled) {
                document.title = whiteLabelers[app.whitelabeler].title;
                if (whiteLabelers[app.whitelabeler].css !== undefined) {
                    loadStylesheet(window.location.origin + "/css/" + whiteLabelers[app.whitelabeler].css, document)
                }
                if (whiteLabelers[app.whitelabeler].favicon !== undefined) {
                    setFavicon(window.location.origin + "/images/" + whiteLabelers[app.whitelabeler].favicon)
                }
            }

        }

        window.addEventListener('load', async () => {
            checkWhitelabel();
            web3ModalInit()
            getLastUsedDevice();
        }, false);

        async function initEthereumAccount() {
            app.providedWeb3 = new Web3(provider);
            web3Account = (await app.providedWeb3.eth.getAccounts())[0];
            app.address = web3Account;
            await AttemptReverse(web3Account);
        }
        
        async function initTezosAccount(onConnect) {
            try {
                if (!app.dAppClient) {
                    app.dAppClient = await new beacon.DAppClient({ name: "TokenCast" });
                }
                activeAccount = await app.dAppClient.getActiveAccount();
                
                if (!activeAccount && onConnect) {
                    console.log("getting permissions");
                    const permissions = await app.dAppClient.requestPermissions();
                    activeAccount = await app.dAppClient.getActiveAccount();
                }
                if (activeAccount) {
                    app.address = activeAccount.address;
                    web3Account = app.address;
                }
            } catch (error) {
                console.log("Tezos Account error:", error);
            }
        }

        async function LoginUser() {
            if (app.network === TEZOS) {
                app.showSignMessage = true;
                await GetSignature();
            } else {
                try {
                    await initEthereumAccount();
                    await GetSignature();
                }
                catch {
                    app.showSignMessage = true;
                    web3ModalInit();
                }
            }
        }

        async function GetAccountIfSignatureExists(network) {
            signature = getCachedSignature(web3Account, network);
            if (signature !== undefined && signature !== "" && signature !== null) {
                if (network === TEZOS) {
                    app.tezosWalletConnected = true;
                } 
                app.showSignMessage = false;
                app.network = network;
                await app.FetchCanviaDevices();
                await GetAccountInfo(true);
            }
        }

        async function AttemptReverse(address) {
            let provider = new ethers.providers.Web3Provider(app.providedWeb3.currentProvider);
            provider.lookupAddress(address).then(function (ensName) {
                if (ensName != null) {
                    app.address = ensName;
                }
            });
        }

        function getSignatureKey(address, walletNetwork) {
            return address + '_signature' + '_' + walletNetwork
        }
        function getCachedSignature(address, walletNetwork) {
            var key = getSignatureKey(address, walletNetwork);
            var cachedSignature = window.localStorage.getItem(key);
            return cachedSignature
        }
        function cacheSignature(signature, address, walletNetwork) {
            var key = getSignatureKey(address, walletNetwork);
            window.localStorage.setItem(key, signature);
        }

        function storeLastUsedDevice(deviceId) {
            app.selected = deviceId;
            window.localStorage.setItem("lastDevice", deviceId);
        }
        function getLastUsedDevice() {
            var deviceId = window.localStorage.getItem("lastDevice");
            app.selected = deviceId;
            return deviceId;
        }

        async function GetSignature() {
            signature = getCachedSignature(web3Account, app.network);
            if (signature === undefined || signature === "" || signature === null) {
                if (!outstandingSignatureRequest) {
                    outstandingSignatureRequest = true;
                    try {
                        if (app.network === TEZOS) {
                            try {
                                console.log("Getting Tezos signature");
                                //const response = await app.dAppClient.requestSignPayload({
                                //    signingType: beacon.SigningType.RAW,
                                //    payload: app.signatureMessage,
                                //});
                                app.tezosWalletConnected = true;
                                //signature = response.signature;
                            }
                            catch (e) {
                                console.log(e);
                            }
                         } else {
                             console.log("Getting Ethereum signature");
                             let plain = app.signatureMessage;
                             let msg = app.providedWeb3.utils.asciiToHex(plain);
                             let hash = app.providedWeb3.utils.keccak256("\x19Ethereum Signed Message:\n" + plain.length + plain);
                             signature = await app.providedWeb3.eth.personal.sign(msg, web3Account);
                         }
                        cacheSignature(signature, web3Account, app.network)
                    }
                    finally {
                        outstandingSignatureRequest = false;
                    }
                }
            }
            if (signature !== undefined && signature !== "" && signature !== null) {
                await app.FetchCanviaDevices();
            }
            await GetAccountInfo(true);
        }

        async function GetAccountInfo(onPageLoad) {
            // Create account if not exist
            $.get("Account/Details?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&whitelabeler=" + app.whitelabeler, function (accountDetails) {
                if (accountDetails != null) {
                    app.showSignMessage = false;
                    app.account = accountDetails;
                    app.showAddDeviceButton = true;
                    if (onPageLoad) {
                        CheckAddDevice(accountDetails);
                    }
                } else {
                    console.log("Error fetching account details");
                }
            });
        }

        async function CheckAddDevice(accountDetails) {

            // Get device id from QS param
            // If present, prompt user to add device
            var urlParams = new URLSearchParams(window.location.search);
            var deviceId = urlParams.get("deviceId");

            if (deviceId != null &&
                (accountDetails.devices == null || accountDetails.devices.indexOf(deviceId) == -1)) {
                AddDevice(deviceId);
            }
            else if (accountDetails.devices != null && accountDetails.devices.length > 0) {
                defaultDeviceId = accountDetails.devices[0];
                GetTokens();
            }
            else {
                // No devices found
                app.showAddDeviceInput = true;
            }
        }

        async function AddDevice(deviceId) {
            $.post("Account/AddDevice?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&deviceId=" + deviceId + "&whitelabeler=" + app.whitelabeler,
                function (result) {
                    if (result == false) {
                        console.log("Failed to link device to account");
                    }
                    else {
                        console.log("Successfully linked device to account");
                        defaultDeviceId = deviceId;
                        GetAccountInfo();
                        GetTokens();
                    }
                });
        }

        async function AddCanviaDevices(code, address) {
            $.post("Account/AddCanviaDevices?address=" + address + "&signature=" + signature + "&network=" + app.network + "&code=" + code + "&whitelabeler=" + app.whitelabeler,
                function (result) {
                    if (result === false) {
                        console.log("Failed to link Canvia account");
                    }
                    else {
                        console.log("Successfully linked Canvia account. Devices Added!");
                        app.showAddDeviceInput = false;
                        GetAccountInfo(true);
                    }
                });
        }

        async function UpdateDevice(deviceId, alias, frequency) {
            $.post("Account/UpdateDevice?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&deviceId=" + deviceId + "&alias=" + alias + "&frequency=" + frequency + "&whitelabeler=" + app.whitelabeler,
                function (result) {
                    if (result == false) {
                        console.log("Failed to add device alias");
                    }
                    else {
                        console.log("Successfully added device alias");
                        GetAccountInfo();
                    }
                });
        }        
        
        async function GetDeviceRotationFrequency(deviceId) {
            $.post("Account/GetDeviceFrequency?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&deviceId=" + deviceId + "&whitelabeler=" + app.whitelabeler,
                function (result) {
                    if (result == null) {
                        console.log("Failed to fetch device rotation frequency");
                    }
                    else {
                        app.rotationFrequency = parseInt(result);
                    }
                });
        }

        async function DeleteDevice(deviceId) {
            $.post("Account/DeleteDevice?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&deviceId=" + deviceId + "&whitelabeler=" + app.whitelabeler,
                function (result) {
                    if (result == false) {
                        console.log("Failed to delete device");
                    }
                    else {
                        console.log("Successfully deleted device");
                        GetAccountInfo();
                    }
                });
        }

        async function RemoveAllTokens(deviceId) {
            $.post("Account/RemoveDeviceContent?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&deviceId=" + deviceId + "&whitelabeler=" + app.whitelabeler,
                function (result) {
                    if (result == false) {
                        alert("Remove Failed");
                    }
                    else {
                        alert("Removed Token!");
                    }
                });
        }        
        
        async function RemoveSingleToken(deviceId, index) {
            $.post("Account/RemoveIndexFromQueue?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&deviceId=" + deviceId + "&index=" + index + "&whitelabeler=" + app.whitelabeler,
                function (result) {
                    if (result == false) {
                        alert("Remove Failed");
                    }
                    else {
                        alert(`Removed Token number ${index + 1}!`);
                        var parsedTokens = JSON.parse(result);
                        app.tokensByDevice = parsedTokens;
                    }
                });
        }
        
        async function GetCastedTokensForDevice(deviceId) {
            $.post("Account/GetCastedTokensForDevice?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&deviceId=" + deviceId + "&whitelabeler=" + app.whitelabeler,
                function (result) {
                    if (result == false) {
                        console.log("Could not get tokens for device");
                    }
                    else {
                        var parsedTokens = JSON.parse(result);
                        app.tokensByDevice = parsedTokens;
                        console.log("Fetched tokens on queue! " + parsedTokens)
                    }
            });
        }

        async function GetTokens() {
            app.showFetchingTokensMessage = true;
            $.get("Account/Tokens?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&whitelabeler=" + app.whitelabeler, function (tokenResponse) {
                app.showNoTokensMessage = false;
                if (tokenResponse == "") {
                    // no tokens found
                    app.showNoTokensMessage = true;
                }
                var parsedTokens = JSON.parse(tokenResponse);
                if (parsedTokens == null || parsedTokens.assets.length == 0) {
                    // no tokens found
                    app.showNoTokensMessage = true;
                }
                app.showFetchingTokensMessage = false;
                app.tokens = [];
                parsedTokens.assets.forEach(function (token) {
                    if (token.image_url != "") {
                        app.tokens.push(token);
                    }
                })
                app.tokensLoaded = true;
            });

            GetCommunityTokens()
        }

        async function GetCommunityTokens() {

            app.showFetchingTokensMessage = true;

            $.get("Account/CommunityTokens", function (tokenResponse) {
                var parsedTokens = JSON.parse(tokenResponse);
                app.showFetchingTokensMessage = false;
                app.communityTokens = [];
                parsedTokens.assets.forEach(function (token) {
                    if (token.image_url != "") {
                        app.communityTokens.push(token);
                    }
                })
            });
        }

        function CopyToClipboard(str) {
            const el = document.createElement('textarea');
            el.value = str;
            el.setAttribute('readonly', '');
            el.style.position = 'absolute';
            el.style.left = '-9999px';
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
        };

        function grabColorFromPos(e) {
            if (e.offsetX) {
                x = e.offsetX;
                y = e.offsetY;
            }
            else if (e.layerX) {
                x = e.layerX;
                y = e.layerY;
            }

            var tokenPreviewContainer = document.getElementById('tokenPreviewContainer');
            var tokenPreviewCanvas = document.getElementById('tokenPreviewCanvas');

            tokenPreviewCanvas.width = tokenPreviewContainer.width;
            tokenPreviewCanvas.height = tokenPreviewContainer.height;
             fitImageOn(tokenPreviewCanvas, tokenPreviewContainer, tokenPreviewContainer.style.objectFit == "contain");
            var p = tokenPreviewCanvas.getContext('2d')
                .getImageData(x, y, 1, 1).data;

            var hexColor = rgbToHex(p[0], p[1], p[2]);
            return hexColor;
        }

        function fitImageOn(canvas, imageObj, contain) {
            var context = canvas.getContext('2d');
            var imageAspectRatio = imageObj.naturalWidth / imageObj.naturalHeight;
            var canvasAspectRatio = canvas.width / canvas.height;
            var renderableHeight, renderableWidth, xStart, yStart;

            // Simulate 'cover' if not contain
            if (!contain) {
                // Width = canvas width
                // Height = ratio
                renderableWidth = canvas.width;
                renderableHeight = canvas.width / imageAspectRatio;
                xStart = 0;
                yStart = (canvas.height - renderableHeight) / 2;
            }
            // If image's aspect ratio is less than canvas's we fit on height
            // and place the image centrally along width
            else if (imageAspectRatio < canvasAspectRatio) {
                renderableHeight = canvas.height;
                renderableWidth = imageObj.naturalWidth * (renderableHeight / imageObj.naturalHeight);
                xStart = (canvas.width - renderableWidth) / 2;
                yStart = 0;
            }

            // If image's aspect ratio is greater than canvas's we fit on width
            // and place the image centrally along height
            else if (imageAspectRatio > canvasAspectRatio) {
                renderableWidth = canvas.width
                renderableHeight = imageObj.naturalHeight * (renderableWidth / imageObj.naturalWidth);
                xStart = 0;
                yStart = (canvas.height - renderableHeight) / 2;
            }

            // Happy path - keep aspect ratio
            else {
                renderableHeight = canvas.height;
                renderableWidth = canvas.width;
                xStart = 0;
                yStart = 0;
            }

            context.drawImage(imageObj, xStart, yStart, renderableWidth, renderableHeight);
        };

        function rgbToHex(r, g, b) {
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }

        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }
    </script>
</head>
    <body>
        <style>
            h1 a {
                text-decoration: none;
                color: white;
            }
            h1 a:hover {
                text-decoration: none;
                color: white;
            }

            .center {
                margin-left: auto;
                margin-right: auto;
            }

            .transformCenter {
                 margin: 0;
                 position: absolute;
                 top: 50%;
                 -ms-transform: translateY(-50%);
                 transform: translateY(-50%);
                 font-size: x-large;
                 left: 50%;
                 transform: translate(-50%, -50%);
            }
                        
            .networkSelection {
                position: absolute;
                display: inline;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
            }
            
            .networkButton {
                width: 200px;
                font-size: x-large;
            }

            .tokenGallery {
                width: 50%;
                min-width: 251px;
                position: relative;
                left: 50%;
                transform: translate(-50%, 7em);
            }

            div.gallery {
                margin: 5px;
                border: 1px solid #ccc;
                float: left;
                border-radius: 5px;
            }

                div.gallery:hover {
                      box-shadow: 0px 0px 40px rgba(0,0,0,0.4);
                      transform: scale(1.01,1.01);
                      border-radius: 5px;
                      transition: opacity 0.3s ease-in-out;
                }

                div.gallery img {
                    width: auto;
                    height: 250px;
                    padding: 15px;
                }
                div.gallery video {
                    width: auto;
                    height: 250px;
                    padding: 15px;
                }
                           
            div.queueGallery {
                margin: 5px;
                border: 1px solid #ccc;
                float: left;
                border-radius: 5px;
            }
                div.queueGallery:hover {
                    box-shadow: 0px 0px 40px rgba(0,0,0,0.4);
                    transform: scale(1.01,1.01);
                    border-radius: 5px;
                    transition: opacity 0.3s ease-in-out;
                }                          
                div.queueGallery img {
                    width: 100px;
                    height: 100px;
                }
                div.queueGallery video {
                    width: 100px;
                    height: 100px;
                }

            div.desc {
                padding: 15px;
                text-align: center;
                font-size: 18px;
                color: #679289;
            }

            .statusMessage {
                margin: 0;
                position: absolute;
                top: 50%;
                -ms-transform: translateY(-50%);
                transform: translateY(-50%);
                font-size: x-large;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            .inlineStatusMessage {
                margin: 0;
                position: relative;
                -ms-transform: translateY(-50%);
                transform: translateY(-50%);
                font-size: x-large;
                left: 50%;
                transform: translate(-50%, 0%);
            }

            #removeContentButtonContainer {
                border-radius: 2px;
                width: 300px;
                position: absolute;
                bottom: -100px;
                right: 25%;
                left: 50%;
                margin-left: -150px;
                padding-bottom: 20px;
            }

            #removeContentButton {
                background-color: darkred;
            }

            .modal {
                position: fixed;
                z-index: 1001;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, .5);
                display: table;
                transition: opacity .3s ease;
            }

            .inputForm {
                z-index: 1002;
                display: grid;
                margin: 0px auto;
                background-color: #fff;
                border-radius: 2px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, .33);
                transition: all .3s ease;
                padding: 3em;
                position: absolute;
                top: 1em;
                left: 50%;
                transform: translate(-50%, 0%);
                width: 100%;
                max-width: 50em;
                max-height: 80%;
                scroll-behavior: unset;
                overflow-y: auto;
                text-align: left;
            }

            .formElement {
                padding-top: .5em;
                font-weight: 500;
            }

            #idBar {
                color: white;
                width: 65%;
            }

            #tokenPreviewContainer {
                background-position: center;
                background-repeat: no-repeat;
                background-size: contain;
                color: #FFFFFF;
                cursor: crosshair;
            }

            .slider {
                -webkit-appearance: none;
                width: 100%;
                height: 15px;
                border-radius: 5px;
                background: #d3d3d3;
                outline: none;
                opacity: 0.7;
                -webkit-transition: .2s;
                transition: opacity .2s;
            }

                .slider::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    appearance: none;
                    width: 25px;
                    height: 25px;
                    border-radius: 50%;
                    background: darkcyan;
                    cursor: pointer;
                }

                .slider::-moz-range-thumb {
                    width: 25px;
                    height: 25px;
                    border-radius: 50%;
                    background: #4CAF50;
                    cursor: pointer;
                }

            .deviceListElement {
                padding-left: 1em;
                font-size: 1.2em;
                color: #000;
                text-align: left;
            }

            input[type=text] {
                font-size: 1.3em;
                padding-left: 5px;
            }

            #header {
                position: absolute;
            }


            @@media only screen and (max-width: 600px) {
                .inputForm {
                    padding: 1em;
                }
            }

        .navbar-title {
            position: relative;
            display: inline-block;
            font-size: 22px;
            padding-left: 10%;
            color: #ffffff;
        }
            /*Hide arrow keys from number inputs*/
            /* Chrome, Safari, Edge, Opera */
            input::-webkit-outer-spin-button,
            input::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }                    
            /* Firefox */
            input[type=number] {
                -moz-appearance: textfield;
            }
        </style>
        <div id="app" style="text-align:center;background-color:#000000">
            <span id="header" class="navbar-title">
                <a>Snitch</a>
            </span>
            <div id="burger"
                 :class="{ 'active' : showHamburger }"
                 v-on:click="ToggleBurger"
                 v-if="walletConnected">
                <slot>
                    <button type="button" class="burger-button" title="Menu">
                        <span class="burger-bar burger-bar--1"></span>
                        <span class="burger-bar burger-bar--2"></span>
                        <span class="burger-bar burger-bar--3"></span>
                    </button>
                </slot>
            </div>
            <div class="sidebar">
                <div class="sidebar-backdrop" style=" z-index: 1;" v-on:click="ToggleBurger" v-if="showHamburger"></div>
                <transition name="slide">
                    <div v-if="showHamburger"
                         class="sidebar-panel">
                        <slot>
                            <ul class="sidebar-panel-nav">
                                <li>
                                    <span id="idBar">
                                        {{ shortenedAddress }}
                                    </span>
                                </li>
                                <li v-if="showAddDeviceButton">
                                    <span v-on:click="showAddDeviceInput = true" style="cursor:pointer">New Device</span>
                                </li>
                                <li v-if="showAddDeviceButton">
                                    <span id="viewDevicesButton" v-on:click="viewDevices = !viewDevices" style="cursor:pointer">
                                        Linked Devices
                                    </span>
                                    <transition name="slide-down">
                                        <div>
                                            <table>
                                                <tr v-for="device in account.devices">
                                                    <td class="deviceListElement" style="cursor:pointer" v-on:click="DeviceSelected(device)">
                                                        {{ GetDeviceAlias(device) }}
                                                    </td>
                                                </tr>
                                            </table>
                                        </div>
                                    </transition>
                                </li>
                                <li style="padding-top:1em">
                                    <span style="cursor:pointer" v-on:click="SignOut">
                                        Sign Out
                                    </span>
                                </li>
                            </ul>
                        </slot>
                    </div>
                </transition>
            </div>
            <div class="networkSelection" v-if="!walletConnected">
                <div class="networkButton button positiveButton" id="web3ConnectButton" v-on:click="EthereumConnect">Ethereum</div>
                <div class="networkButton button positiveButton" id="tezozWalletConnect" v-on:click="TezosConnect">Tezos</div>
            </div>
            <div class="transformCenter" v-if="walletConnected && showSignMessage">Please sign the payload to prove ownership over your account</div>
            <div class="transformCenter" v-if="walletConnected && showFetchingTokensMessage">Fetching tokens...</div>
            <div class="tokenGallery">
                <div v-if="tokensLoaded">
                    <h3>
                        Browse your NFTs
                    </h3>
                </div>
                <div class="inlineStatusMessage" v-if="showNoTokensMessage" style="width: 80%; min-width: 13em;">
                    Unable to find any tokens
                    <div>Get yours at</div>
                    <div v-if="network === 'ETHEREUM'" style="display: flex; align-items: flex-start; flex-wrap: nowrap;">
                        <div style="width:40%;"><a class="button center positiveButton" href="https://knownorigin.io/">KnownOrigin</a></div>
                        <div style="width:40%;"><a class="button center positiveButton" href="https://superrare.co/">SuperRare</a></div>
                        <div style="width:40%;"><a class="button center positiveButton" href="https://opensea.io/">OpenSea</a></div>
                    </div>
                    <div v-if="network === 'TEZOS'" style="display: flex; align-items: flex-start; flex-wrap: nowrap;">
                        <div style="width:40%;" class="center">
                            <a class="button center positiveButton" href="https://www.hicetnunc.xyz/">
                                <img src="https://www.hicetnunc.xyz/hen-pride.gif" style="width: 11em; height: auto; ">
                             </a></div>
                    </div>
                </div>
                <div v-if="tokensLoaded" v-for="token in tokens" class="gallery" style="width: 48%; min-width: 250px;" v-on:click="TokenSelected(token, true)">
                    <a v-lazyload>
                        <div class="loader center"></div>
                        <img  :data-url="token.image_url" v-bind:alt="token.name" width="600" height="400" style="max-width: 95%">
                    </a>
                    <div class="desc">{{ token.name }}</div>
                </div>
            </div>

            <div style="width:100%;height: 3em;display: flex;"></div>

            <div class="tokenGallery" style="background-color:#000000">
                <div v-if="tokensLoaded" style="position:relative; top: 1em; z-index:-1;">
                    <h3>
                        Discover new NFTs
                    </h3>
                </div>
                <div v-if="tokensLoaded" v-for="token in communityTokens" class="gallery" style="width: 48%; min-width: 250px; position:relative; top: 1em;" v-on:click="TokenSelected(token, false)">
                    <a>
                        <img v-bind:src="token.image_url" v-bind:alt="token.name" width="600" height="400" style="max-width: 95%">
                    </a>
                    <div class="desc">{{ token.name }}</div>
                </div>
            </div>

            <div class="inputForm" v-if="showAddDeviceInput">
                <h3 style="padding-bottom: 1em;">Register New Device</h3>
                <a id="demoLink" v-on:click="AddDemoDeviceWithForm()" style="text-decoration: underline; color:darkcyan; cursor:pointer;">Try a demo instead</a>
                <a id="canviaDeviceLink" v-if="!whitelabeled" v-on:click="OAuthWithCanvia()" style="text-decoration: underline; color:darkcyan; cursor:pointer;">Connect with Canvia</a>
                <span class="formElement">DeviceId</span>
                <input id="deviceIdInput" type="text" placeholder="Device Id (ex: zero_one_two_three)" style="width: 97%; max-width: 28em;" />
                <button class="button center positiveButton largeButton" v-on:click="AddDeviceWithForm()">Add</button>
            </div>

            <div class="inputForm" v-if="showDeviceEdit">
                <h1 style="padding-bottom: 1em;">Device</h1>
                <div class="formElement">
                    <h4 class="menuFont">Name</h4>
                    <input type="text" id="deviceAliasInput" placeholder="ex. Living room" :value="selectedDeviceAlias" style="width:16em" />
                </div>
                <div style="padding-top: 1em">
                    <h4 class="menuFont">Options</h4>
                    <div style="display: flex; align-items: flex-start; flex-wrap: nowrap;">
                        <div style="width:40%;"><button class="button flexButton negativeButton" id="deleteDeviceButton" v-on:click="DeleteDeviceWithForm()">Delete</button></div>
                        <div style="width:40%; border-color: darkred;"><button class="button flexButton defaultButton" id="clearDeviceButton" v-on:click="ClearDeviceWithForm()">Clear</button></div>
                        <div style="width:40%; border-color: darkred;"><button class="button flexButton defaultButton" id="shareDeviceButton" v-on:click="ShareDeviceWithForm()">Share</button></div>
                        <div style="width:40%;"><button class="button positiveButton" id="updateDeviceButton" v-on:click="UpdateDeviceWithForm()">Update</button></div>
                    </div>
                </div>

                <div v-if="tokensByDevice.length > 0 && !isCanviaDevice" style="padding-top: 1em">
                    <span><h4 class="menuFont">On Queue <i>(select to remove)</i></h4></span>
                </div>
                <div>
                    <div v-if="!isCanviaDevice"
                         v-for="(token, index) in tokensByDevice"
                         class="queueGallery"
                         style="width: 100px; height: 100px; display: flex;"
                         :key="token.tokenImageUrl">
                        <a v-lazyload>
                          <img v-on:click="RemoveTokenFromDevice(index);" v-if="token.tokenImageUrl.indexOf('mp4') === -1" 
                                 :data-url="token.tokenImageUrl" v-bind:alt="token.tokenName" width="100" height="100" style="padding-right:10px"/>
                            <video id="video"
                                   v-on:click="RemoveTokenFromDevice(index);"
                                   v-if="token.tokenImageUrl.indexOf('mp4') > -1"
                                   width="100" height="100"
                                   style="padding-right:10px;"
                                   loop autoplay muted>
                                <source :src="token.tokenImageUrl" type="video/mp4"/>
                            </video>
                        </a>
                    </div>
                </div>
                <div v-if="!isCanviaDevice" style="padding-top: 1em">
                    <div class="formElement">
                        <h4 class="menuFont">Queue Rotation Frequency</h4>
                        <input type="range" id="frequencyOfRotation" min="1" max="10" 
                               v-on:input="GetLogOf()"
                               :value=Math.log2(rotationFrequency)
                               style="width: 50%"
                        >
                        <output id="frequencyOutputValue">{{ rotationFrequency }}</output><b> minutes</b>
                    </div>
                </div>
            </div>

            <div class="modal" v-if="showModal" v-on:click="CloseInputForms()">
            </div>

            <div class="inputForm" v-if="showTokenDisplayOptions">
                <h2 style="padding-bottom: 1em;">Cast your token</h2>
                <div class="center"
                     style="width:100%"
                     v-bind:style="{
                     backgroundColor: selectedBackgroundColor,
                     maxWidth: tokenPreviewWidth + 'px',
                     height: tokenPreviewHeight + 'px'
                 }">
                    <img id="tokenPreviewContainer"
                         class="center"
                         style="width:100%;"
                         crossorigin="anonymous"
                         v-on:click="TokenPreviewClick"
                         v-on:mousemove="TokenPreviewMousemove"
                         v-on:mouseout="TokenPreviewMouseout"
                         v-bind:src="selectedToken.image_url"
                         v-bind:style="{
                            backgroundColor: selectedBackgroundColor,
                            height:tokenHeight,
                            marginTop: borderWidthInPx,
                            objectFit: fitScreen? 'cover' : 'contain'
                     }" />
                </div>
                <div style="padding-top:3em; text-align:left;">
                    <div class="menuFont">Background color</div>
                    <div v-for="color in backgroundColorPallete"
                         class="gallery"
                         v-on:click="ColorSelected(color)"
                         v-bind:style="{ backgroundColor: color }"
                         style="width: 2em; height: 2em;">
                    </div>
                    <div id="colorPicker"
                         style="width: 2em;
                                height: 2em;
                                background-size: contain;
                                cursor: pointer"
                         v-on:click="ColorSelected(eyedropperSelectedColor)"
                         v-bind:style="{backgroundColor: eyedropperHoverColor,
                                        backgroundImage: eyedropperImage}"
                         class="gallery">
                    </div>
                </div>
                <div style="padding-top:1em; text-align:left;">
                    <div class="menuFont">Border width percentage</div>
                    <div style="width:100%">
                        <input type="range" min="0" max="35" value="5" class="slider" v-model="borderWidthPercent">
                    </div>
                    <div class="menuFont">Fit screen</div>
                    <input type="checkbox" v-model="fitScreen" v-on:click="borderWidthPercent = !fitScreen? 0 : borderWidthPercent" />
                    <div class="menuFont">Rotate orientation</div>
                    <input type="checkbox" v-model="orientationVertical" />
                    <span v-if="displayingOwnedToken">
                        <div class="menuFont">Show Metadata</div>
                        <input type="checkbox" v-model="showMetadata" />
                    </span>
                </div>
                <div style="padding-top:1em; text-align:left;" class="menuFont">Device</div>
                <select id="deviceSelection" style="margin-top:.5em; margin-bottom:.5em; " v-model="selected">
                    <option v-for="device in account.devices" :value="device">
                        {{ GetDeviceAlias(device) }}
                    </option>
                </select>
                <button class="button center positiveButton largeButton" id="displayTokenButton" v-on:click="CastToken()">Cast</button>
            </div>
            <canvas id="tokenPreviewCanvas" style="display:none;"
                    v-bind:style="{
                        objectFit: fitScreen? 'fill' : 'contain',
                        height:tokenHeight,
                        marginTop: borderWidthInPx}">
            </canvas>
        </div>

        <script type="text/javascript">
            web3Account = "";
            signature = ""

            var app = new Vue({
                el: '#app',
                data: {
                    address: '',
                    account: '',
                    network: '',
                    tokens: '',
                    communityTokens: '',
                    showSignMessage: true,
                    showFetchingTokensMessage: false,
                    tokensLoaded: false,
                    tokensByDevice: [],
                    showNoTokensMessage: false,
                    showAddDeviceButton: false,
                    showAddDeviceInput: false,
                    isBurgerActive: false,
                    viewDevices: false,
                    showTokenDisplayOptions: false,
                    selectedToken: null,
                    backgroundColorPallete: [],
                    selectedBackgroundColor: "#ffffff",
                    tokenPreviewHeight: 300,
                    tokenPreviewWidth: 500,
                    borderWidthPercent: 5,
                    borderWidthInPx: '0px',
                    fitScreen: false,
                    orientationVertical: false,
                    showMetadata: true,
                    selectedDeviceId: '',
                    selectedDeviceAlias: '',
                    isCanviaDevice: '',
                    rotationFrequency: '',
                    showDeviceEdit: false,
                    eyedropperSelectedColor: "#ffffff",
                    eyedropperHoverColor: "#ffffff",
                    displayingOwnedToken: true,
                    providedWeb3: '',
                    dAppClient: '',
                    tezosWalletConnected: false,
                    whitelabeler: '',
                    selected: ''
                },
                mounted: async function () {
                    await onLoad(true, false);                      
                },
                computed: {
                    walletConnected: function () {
                        return this.providedWeb3 !== '' || this.tezosWalletConnected === true
                    },
                    showModal: function () {
                        var shouldShowModal = this.showTokenDisplayOptions || this.showAddDeviceInput || this.showDeviceEdit;
                        if (shouldShowModal) {
                            $('html,body').scrollTop(0);
                        }
                        return shouldShowModal;
                    },
                    tokenHeight: function () {
                        var borderWidthInPx = this.borderWidthPercent * .01 * this.tokenPreviewHeight;
                        this.borderWidthInPx = borderWidthInPx + "px";
                        var borderHeight = borderWidthInPx * 2;
                        return (this.tokenPreviewHeight - borderHeight) + "px";
                    },
                    shortenedAddress: function () {
                        var addressLength = this.address.length;
                        if (addressLength > 20) {
                            return this.address.substring(0, 7) + "..." + this.address.substring(addressLength - 8, addressLength);
                        }
                        return this.address;
                    },
                    showHamburger: function () {
                        return this.isBurgerActive && !this.showModal;
                    },
                    eyedropperImage: function () {
                        var c = this.eyedropperHoverColor.substring(1);      // strip #
                        var rgb = parseInt(c, 16);   // convert rrggbb to decimal
                        var r = (rgb >> 16) & 0xff;  // extract red
                        var g = (rgb >>  8) & 0xff;  // extract green
                        var b = (rgb >>  0) & 0xff;  // extract blue

                        var luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709

                        if (luma < 100) {
                            // pick a different colour
                            return "url('images/eye_dropper_white.png')";
                        }
                        else {
                            return "url('images/eye_dropper.png')";
                        }
                    },
                    whitelabeled: function () {
                        return !!this.whitelabeler && !!whiteLabelers[this.whitelabeler]
                    },
                    title: function () {
                        if (!this.whitelabeled) {
                            return "TokenCast";
                        }
                        return whiteLabelers[this.whitelabeler].title
                    },
                    homeUrl: function () {
                        if (!this.whitelabeled) {
                            return "https://tokencast.net";
                        }
                        return whiteLabelers[this.whitelabeler].url + "/account?whitelabel=" + this.whitelabeler
                    },
                    hasLogo: function () {
                        if (!this.whitelabeled) {
                            return false;
                        }
                        return whiteLabelers[this.whitelabeler].logo !== undefined
                    },
                    logoImageUrl: function () {
                        if (!this.whitelabeled) {
                            return false;
                        }
                        return "images/" + whiteLabelers[this.whitelabeler].logo
                    },
                    signatureMessage: function () {
                        if (!this.whitelabeled || !whiteLabelers[this.whitelabeler].signatureMessage) {
                            return 'TokenCast - proof of ownership. Please sign this message to prove ownership over your Ethereum account.';
                        }
                        return whiteLabelers[this.whitelabeler].signatureMessage
                    }
                },
                methods: {
                    EthereumConnect: function () {
                        onConnectEthereum();
                    },                    
                    TezosConnect: function () {
                        onConnectTezos();
                    },
                    SignOut: async function () {
                        this.isBurgerActive = false;
                        await web3Modal.clearCachedProvider();
                        this.providedWeb3 = '';
                        this.tokensLoaded = false;
                        this.tezosWalletConnected = false;
                        this.showNoTokensMessage = false;
                        window.localStorage.removeItem(getSignatureKey(app.address, app.network));
                        if (app.dAppClient) {
                            await app.dAppClient.clearActiveAccount();
                        }
                    },
                    FetchCanviaDevices: async function () {
                        const queryString = window.location.search;
                        const urlParams = new URLSearchParams(queryString);
                        const code = urlParams.get('code');
                        if (code !== null) {
                            await AddCanviaDevices(code, app.address);
                        }                      
                    },
                    OAuthWithCanvia: function () {
                        this.showAddDeviceInput = false;
                        const canviaLoginlink = "https://prod.palacio.life/backend/oauth/login.html?client_id=659fb248-18dc-497e-9b31-3419935e555f&grant_type=authorization_code&response_type=code";                         
                        window.open(canviaLoginlink);
                    },                                          
                    TokenSelected: function (token, ownedToken) {
                        this.backgroundColorPallete = [];
                        this.selectedBackgroundColor = "#ffffff";
                        this.selectedToken = token;
                        // Generate color pallete
                        var vibrantOptions = {
                            colorCount: 7
                        };
                        if (token.background_color != null) {
                            this.backgroundColorPallete.push("#" + token.background_color);
                            this.selectedBackgroundColor = "#" + token.background_color;
                        }
                        if ("#" + token.background_color != "#ffffff") {
                            this.backgroundColorPallete.push("#ffffff");
                        }
                        if ("#" + token.background_color != "#000000") {
                            this.backgroundColorPallete.push("#000000");
                        }
                        var vibrant = new Vibrant(token.image_url, vibrantOptions);
                        vibrant.getPalette((err, palette) => {
                            for (var color in palette) {
                                this.backgroundColorPallete.push(palette[color].hex);
                            };
                        });
                        this.showTokenDisplayOptions = true;
                        this.displayingOwnedToken = ownedToken;
                        this.showMetadata = true;
                    },
                    DeviceSelected: function (deviceId) {
                        this.selectedDeviceAlias = this.GetDeviceAlias(deviceId);
                        this.isCanviaDevice = this.GetIsCanviaDevice(this.selectedDeviceAlias);
                        this.selectedDeviceId = deviceId;
                        this.showDeviceEdit = true;
                        GetDeviceRotationFrequency(deviceId)
                        this.GetTokensOnQueue()
                    },
                    GetDeviceAlias: function (deviceId) {
                        if (this.account.deviceMapping && deviceId in this.account.deviceMapping) {
                            return this.account.deviceMapping[deviceId];
                        }

                        return deviceId;
                    },                    
                    GetIsCanviaDevice: function (deviceId) {
                        if (this.account.canviaAccount.canviaDevices && deviceId in this.account.canviaAccount.canviaDevices) {
                            return true
                        }

                        return false;
                    },
                    CastToken: function () {
                        this.showTokenDisplayOptions = false;
                        var token = this.selectedToken;
                        var device = document.getElementById("deviceSelection").value;
                        storeLastUsedDevice(device)
                        // Prefer animation if it exists
                        var tokenImageUrl = token.animation_url
                        if (!token.animation_url) {
                            if (token.image_original_url) {
                                tokenImageUrl = token.image_original_url
                            }
                            else {
                                tokenImageUrl = token.image_url
                            }
                        }
                        var content =
                        {
                            id: device,
                            currentDisplay: {
                                tokenName: this.showMetadata? token.name : "",
                                tokenOwnershipUrl: this.showMetadata? token.permalink : "",
                                tokenMetadata: this.showMetadata? token.description : "",
                                tokenImageUrl,
                                borderWidthPercent: this.borderWidthPercent,
                                rotationFrequency: this.rotationFrequency,
                                fitScreen: this.fitScreen,
                                backgroundColor: this.selectedBackgroundColor,
                                orientationVertical: this.orientationVertical,
                                currentPrice: token.current_price
                            }
                        }
                        $.post("Account/SetDeviceContent?address=" + web3Account + "&signature=" + signature + "&network=" + app.network + "&whitelabeler=" + app.whitelabeler,
                            content,
                            function (result) {
                                if (result == false) {
                                    alert("Cast Failed");
                                }
                                else {
                                    alert("Token Added To Queue!");
                                }
                            });
                    },
                    AddDeviceWithForm: function () {
                        this.showAddDeviceInput = false;
                        var deviceId = document.getElementById("deviceIdInput").value;
                        document.getElementById("deviceIdInput").value = "";
                        AddDevice(deviceId);
                    },
                    AddDemoDeviceWithForm: function () {
                        this.showAddDeviceInput = false;
                        var deviceId = words({ exactly: 1, wordsPerString: 3, separator: '_' }) + "_demo";
                        document.getElementById("deviceIdInput").value = "";
                        AddDevice(deviceId);
                        // Open demo link in new tab
                        var demoLink = "https://tokencast.net/device?demoFrame=true&deviceId=" + deviceId;
                        window.open(demoLink)
                    },
                    UpdateDeviceWithForm: function () {
                        this.showDeviceEdit = false;
                        var deviceId = this.selectedDeviceId;
                        var alias = document.getElementById("deviceAliasInput").value;
                        var frequency = document.getElementById("frequencyOutputValue").value;
                        UpdateDevice(deviceId, alias, frequency);
                    },                    
                    GetTokensOnQueue: function () {
                        var deviceId = this.selectedDeviceId;
                        GetCastedTokensForDevice(deviceId);
                    },
                    DeleteDeviceWithForm: function () {
                        this.showDeviceEdit = false;
                        var deviceId = this.selectedDeviceId;
                        DeleteDevice(deviceId);
                    },
                    ClearDeviceWithForm: function () {
                        var deviceId = this.selectedDeviceId;
                        RemoveAllTokens(deviceId);
                    },                    
                    RemoveTokenFromDevice: function (index) {
                        var deviceId = this.selectedDeviceId;
                        RemoveSingleToken(deviceId, index);
                    },
                    ShareDeviceWithForm: function () {
                        var deviceId = this.selectedDeviceId;
                        var shareLink = "https://www.tokencast.net/Account?deviceId=" + deviceId;

                        if (navigator.share) {
                            // From mobile device
                            navigator.share({
                                title: 'TokenCast Device',
                                text: 'Display tokens to this device.',
                                url: shareLink,
                            })
                                .then(() => console.log('Successful share'))
                                .catch((error) => console.log('Error sharing', error));
                        }
                        else {
                            // From PC
                            CopyToClipboard(shareLink);
                            alert("Copied sharable link!");
                        }
                    },
                    CloseInputForms: function () {
                        this.showTokenDisplayOptions = false;
                        this.showAddDeviceInput = false;
                        this.showDeviceEdit = false;
                    },
                    ColorSelected: function (color) {
                        this.selectedBackgroundColor = color;
                    },
                    ToggleBurger: function () {
                        this.isBurgerActive = !this.isBurgerActive
                    },
                    TokenPreviewClick: function (e) {
                        var color = grabColorFromPos(e);
                        this.eyedropperSelectedColor = color;
                        this.selectedBackgroundColor = color;
                    },
                    TokenPreviewMousemove: function (e) {
                        var color = grabColorFromPos(e);
                        this.eyedropperHoverColor = color;
                    },
                    TokenPreviewMouseout: function () {
                        this.eyedropperHoverColor = this.eyedropperSelectedColor;
                    },
                    GetLogOf: function (){
                        var input = document.getElementById("frequencyOfRotation")
                        this.rotationFrequency = Math.pow(2, input.value)
                    }
                },
                directives: {
                    lazyload: {
                        inserted: function(el) {
                            function loadImage() {
                                const imageElement = Array.from(el.children).find(
                                    el => el.nodeName === "IMG"
                                );
                                if (imageElement) {
                                    imageElement.addEventListener("load", () => {
                                        setTimeout(() => el.classList.add("loaded"), 100);
                                    });
                                    imageElement.addEventListener("error", () => console.log("error"));
                                    imageElement.src = imageElement.dataset.url;
                                }
                                const loaderElement = Array.from(el.children).find(
                                    el => el.nodeName === "DIV"
                                );

                                if (loaderElement) {
                                    loaderElement.style.display = "none"
                                }
                            }

                            function handleIntersect(entries, observer) {
                                entries.forEach(entry => {
                                    if (entry.isIntersecting) {
                                        loadImage();
                                        observer.unobserve(el);
                                    }
                                });
                            }

                            function createObserver() {
                                const options = {
                                    root: null,
                                    threshold: "0"
                                };
                                const observer = new IntersectionObserver(handleIntersect, options);
                                observer.observe(el);
                            }
                            if (window["IntersectionObserver"]) {
                                createObserver();
                            } else {
                                loadImage();
                            }
                        }
                    }
                }
            });


            window.onload = function () {
                onLoad(false, true);
            }
        </script>
    </body>